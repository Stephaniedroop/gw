CS=tmp$CS),
br = tmp$br,
tau = tmp$tau)
# Call function 1 from `modelUtils` file
mpp <- get_mod_pred(structures[bpix,], fitted_path_params)
mpd <- get_mod_pred(structures[bdix,], fitted_destination_params)
df.m <- data.frame(situation = situations,
td_path = td_path,
td_destination = td_destination,
mp_path = mpp,
mp_destination = mpd)
# Results in 2 dfs, each of 59049 obs of 13 vars
save(df.m,
best_path,
best_path_params,
best_destination,
best_destination_params,
file = here('Exp1Prediction', 'Model', 'Data', 'model.rda'))
# Load the target distribution and the model prediction for each of the 16 situations
load(here('Exp1Prediction', 'Model', 'Data', 'model.Rda'))  # Actually this is not saved yet; it will be but for now use
# A function to get the causal formulas to send for dagify
# @param causevector A vector of 0s and 1s indicating which variables are included in the best fitting model
# @param state_names A vector of the names of the states corresponding to the causevector
get_formulas <- function(causevector, state_names) {
vars <- state_names[causevector == 1]  # Get the names of the vars that are 1 in best_path
# set up an empty list of formulas
formulas <- list()
# If there is more than 1 cause variables, add a formula between them, to represent an edge
if (length(vars) > 1) {
for (i in 1:(length(vars) - 1)) {
from_var <- vars[i]
to_var <- vars[i + 1]
# set a formula to add to the formulas list of to_var being predicted by from_var
formula <- paste(to_var, "~", from_var)
# Add this formula to the list of formulas
if (i == 1) {
formulas <- list(formula)
} else {
formulas <- c(formulas, list(formula))
}
}
vars_u <- paste0(vars, "u")  # Add 'u' to each of these names
all_vars <- c(vars, vars_u)  # Combine the two sets of names
varsforform <- paste(all_vars, collapse = " + ")  # Create a string with all names separated by ' + '
formula1 <- paste("Path ~", varsforform)  # Create the first, path formula string
formulas <- c(formula1, formulas)  # Combine into a list of formulas
}
return(formulas)
}
# Test the function get_formulas
formulaP <- get_formulas(best_path, state_names)
print(formulaP)  # "Path ~ C + PC + Cu + PCu" and "PC ~ C"
# It returns a list of character strings, not actual formulas, so turn it to formulas
formula_listP <- lapply(formulaP, as.formula)
View(fitted_destination_params)
best_path_tmp <- c(0, 0, 1, 0, 0, 1, 0, 0, 0, 0)
best_destination
?unname
unname(best_path)
# A function to get the causal formulas to send for dagify
# @param causevector A vector of 0s and 1s indicating which variables are included in the best fitting model
# @param state_names A vector of the names of the states corresponding to the causevector
get_formulas <- function(causevectornamed, state_names) {
causevector <- unname(causevectornamed)
vars <- state_names[causevector == 1]  # Get the names of the vars that are 1 in best_path
# set up an empty list of formulas
formulas <- list()
# If there is more than 1 cause variables, add a formula between them, to represent an edge
if (length(vars) > 1) {
for (i in 1:(length(vars) - 1)) {
from_var <- vars[i]
to_var <- vars[i + 1]
# set a formula to add to the formulas list of to_var being predicted by from_var
formula <- paste(to_var, "~", from_var)
# Add this formula to the list of formulas
if (i == 1) {
formulas <- list(formula)
} else {
formulas <- c(formulas, list(formula))
}
}
vars_u <- paste0(vars, "u")  # Add 'u' to each of these names
all_vars <- c(vars, vars_u)  # Combine the two sets of names
varsforform <- paste(all_vars, collapse = " + ")  # Create a string with all names separated by ' + '
formula1 <- paste("Path ~", varsforform)  # Create the first, path formula string
formulas <- c(formula1, formulas)  # Combine into a list of formulas
}
return(formulas)
}
# Test the function get_formulas
formulaP <- get_formulas(best_path, state_names)
print(formulaP)  # "Path ~ C + PC + Cu + PCu" and "PC ~ C"
# A function to get the causal formulas to send for dagify
# @param causevector A vector of 0s and 1s indicating which variables are included in the best fitting model
# @param state_names A vector of the names of the states corresponding to the causevector
get_formulas <- function(causevectornamed, state_names) {
causevector <- as.numeric(causevectornamed)
vars <- state_names[causevector == 1]  # Get the names of the vars that are 1 in best_path
# set up an empty list of formulas
formulas <- list()
# If there is more than 1 cause variables, add a formula between them, to represent an edge
if (length(vars) > 1) {
for (i in 1:(length(vars) - 1)) {
from_var <- vars[i]
to_var <- vars[i + 1]
# set a formula to add to the formulas list of to_var being predicted by from_var
formula <- paste(to_var, "~", from_var)
# Add this formula to the list of formulas
if (i == 1) {
formulas <- list(formula)
} else {
formulas <- c(formulas, list(formula))
}
}
vars_u <- paste0(vars, "u")  # Add 'u' to each of these names
all_vars <- c(vars, vars_u)  # Combine the two sets of names
varsforform <- paste(all_vars, collapse = " + ")  # Create a string with all names separated by ' + '
formula1 <- paste("Path ~", varsforform)  # Create the first, path formula string
formulas <- c(formula1, formulas)  # Combine into a list of formulas
}
return(formulas)
}
# Test the function get_formulas
formulaP <- get_formulas(best_path, state_names)
print(formulaP)
get_formulas <- function(causevector, state_names = names(causevector)) {
if (is.null(state_names)) {
state_names <- paste0("V", seq_along(causevector))
}
vars <- state_names[causevector == 1]
formulas <- list()
if (length(vars) > 1) {
for (i in 1:(length(vars) - 1)) {
from_var <- vars[i]
to_var <- vars[i + 1]
formula <- paste(to_var, "~", from_var)
formulas <- c(formulas, list(formula))
}
}
vars_u <- paste0(vars, "u")
all_vars <- c(vars, vars_u)
varsforform <- paste(all_vars, collapse = " + ")
formula1 <- paste("Path ~", varsforform)
formulas <- c(list(formula1), formulas)
return(formulas)
}
# Test the function get_formulas
formulaP <- get_formulas(best_path, state_names)
print(formulaP)
get_formulas <- function(causevector, state_names = names(causevector)) {
if (is.null(state_names)) {
state_names <- paste0("V", seq_along(causevector))
}
vars <- state_names[causevector != 0]
formulas <- list()
if (length(vars) > 1) {
for (i in 1:(length(vars) - 1)) {
from_var <- vars[i]
to_var <- vars[i + 1]
formula <- paste(to_var, "~", from_var)
formulas <- c(formulas, list(formula))
}
}
vars_u <- paste0(vars, "u")
all_vars <- c(vars, vars_u)
varsforform <- paste(all_vars, collapse = " + ")
formula1 <- paste("Path ~", varsforform)
formulas <- c(list(formula1), formulas)
return(formulas)
}
# Test the function get_formulas
formulaP <- get_formulas(best_path, state_names)
print(formulaP)
# Function to get edges for dagify, in the form of formulas
# The main logic of the function is that for any variables that are included (1s or -1s in causevector)
# it also needs to get the corresponding '-u' variable (unobserved cause), which is an edge going straight from '-u' to effect
# Then it needs to get the edges from the interaction variables back to their constituent variables (but only the ones that are 1,-1)
get_formulas <- function(causevector, state_names = names(causevector)) {
if (is.null(state_names)) {
state_names <- paste0("V", seq_along(causevector))
}
vars <- state_names[causevector != 0]
formulas <- list()
if (length(vars) > 1) {
for (i in 1:(length(vars) - 1)) {
from_var <- vars[i]
to_var <- vars[i + 1]
formula <- paste(to_var, "~", from_var)
formulas <- c(formulas, list(formula))
}
}
vars_u <- paste0(vars, "u")
all_vars <- c(vars, vars_u)
varsforform <- paste(all_vars, collapse = " + ")
formula1 <- paste("Path ~", varsforform)
formulas <- c(list(formula1), formulas)
return(formulas)
}
# Function to get edges for dagify, in the form of formulas
# The main logic of the function is that for any variables that are included (1s or -1s in causevector)
# it also needs to get the corresponding '-u' variable (unobserved cause), which is an edge going straight from '-u' to effect
# Then it needs to get the edges from the interaction variables back to their constituent variables (but only the ones that are 1,-1)
get_formulas <- function(causevector, state_names = names(causevector)) {
if (is.null(state_names)) {
state_names <- paste0("V", seq_along(causevector))
}
vars <- state_names[causevector != 0]
formulas <- list()
if (length(vars) > 1) {
for (i in 1:(length(vars) - 1)) {
from_var <- vars[i]
to_var <- vars[i + 1]
formula <- paste(to_var, "~", from_var)
formulas <- c(formulas, list(formula))
}
}
vars_u <- paste0(vars, "u")
all_vars <- c(vars, vars_u)
varsforform <- paste(all_vars, collapse = " + ")
# Change this manually between 'Path' and 'Destination' for now
formula1 <- paste("Path ~", varsforform)
formulas <- c(list(formula1), formulas)
return(formulas)
}
# Test the function get_formulas
formulaP <- get_formulas(best_path, state_names)
print(formulaP)
# Function to get edges for dagify, in the form of formulas
# The main logic of the function is that for any variables that are included (1s or -1s in causevector)
# it also needs to get the corresponding '-u' variable (unobserved cause), which is an edge going straight from '-u' to effect
# Then it needs to get the edges from the interaction variables back to their constituent variables (but only the ones that are 1,-1)
get_formulas <- function(causevector, state_names = names(causevector)) {
if (is.null(state_names)) {
state_names <- paste0("V", seq_along(causevector))
}
vars <- state_names[causevector != 0]
formulas <- list()
# This next 'if' section gets the edges between single vars and interaction vars
# If there is more than one item in causevector then it has later predicted by earlier
if (length(vars) > 1) {
for (i in 1:(length(vars) - 1)) {
from_var <- vars[i]
to_var <- vars[i + 1]
formula <- paste(to_var, "~", from_var)
formulas <- c(formulas, list(formula))
}
}
vars_u <- paste0(vars, "u")
# Anything in causevector, plus its unobserved counterpart, goes to Path
all_vars <- c(vars, vars_u)
varsforform <- paste(all_vars, collapse = " + ")
# Change this manually between 'Path' and 'Destination' for now
formula1 <- paste("Destination ~", varsforform)
formulas <- c(list(formula1), formulas)
return(formulas)
}
# Test the function get_formulas
formulaP <- get_formulas(best_destination, state_names)
print(formulaP)
get_formulas <- function(causevector) {
# if (is.null(state_names)) {
#   state_names <- paste0("V", seq_along(causevector))
# }
state_names = names(causevector)
vars <- state_names[causevector != 0]
formulas <- list()
# This next 'if' section gets the edges between single vars and interaction vars
# If there is more than one item in causevector then it has later predicted by earlier
if (length(vars) > 1) {
for (i in 1:(length(vars) - 1)) {
from_var <- vars[i]
to_var <- vars[i + 1]
formula <- paste(to_var, "~", from_var)
formulas <- c(formulas, list(formula))
}
}
vars_u <- paste0(vars, "u")
# Anything in causevector, plus its unobserved counterpart, goes to Path
all_vars <- c(vars, vars_u)
varsforform <- paste(all_vars, collapse = " + ")
# Change this manually between 'Path' and 'Destination' for now
formula1 <- paste("Destination ~", varsforform)
formulas <- c(list(formula1), formulas)
return(formulas)
}
# Test the function get_formulas
formulaP <- get_formulas(best_destination, state_names)
# Test the function get_formulas
formulaP <- get_formulas(best_destination)
print(formulaP)
get_formulas <- function(causevector) {
state_names = names(causevector)
vars <- state_names[causevector != 0]
formulas <- list()
# This next 'if' section gets the edges between single vars and interaction vars
# If there is more than one item in causevector then it has later predicted by earlier
if (length(vars) > 1) {
for (i in 1:(length(vars) - 1)) {
from_var <- vars[i]
to_var <- vars[i + 1]
formula <- paste(to_var, "~", from_var)
formulas <- c(formulas, list(formula))
}
}
vars_u <- paste0(vars, "u")
# Anything in causevector, plus its unobserved counterpart, goes to Path
all_vars <- c(vars, vars_u)
varsforform <- paste(all_vars, collapse = " + ")
# Change this manually between 'Path' and 'Destination' for now
formula1 <- paste("Destination ~", varsforform)
formulas <- c(list(formula1), formulas)
return(formulas)
}
# Test the function get_formulas
formulaP <- get_formulas(best_destination)
print(formulaP)
get_formulas <- function(causevector) {
state_names = names(causevector)
vars <- state_names[causevector != 0]
singles <- vars[nchar(vars) == 1]
interactions <- vars[nchar(vars) == 2]
formulas <- list()
# This next 'if' section gets the edges between single vars and interaction vars
# If there is at least one interaction var and single vars, then for each interaction var have a formula where the interaction var predicts its constituent single vars
if (length(interactions) > 0 & length(singles) > 0)
{
for (int_var in interactions) {
constituents <- unlist(strsplit(int_var, split = ""))
for (constituent in constituents) {
if (constituent %in% singles) {
formula <- paste(int_var, "~", constituent)
formulas <- c(formulas, list(formula))
}
}
}
}
# if (length(vars) > 1) {
#   for (i in 1:(length(vars) - 1)) {
#     from_var <- vars[i]
#     to_var <- vars[i + 1]
#     formula <- paste(to_var, "~", from_var)
#     formulas <- c(formulas, list(formula))
#   }
# }
vars_u <- paste0(vars, "u")
# Anything in causevector, plus its unobserved counterpart, goes to Path
all_vars <- c(vars, vars_u)
varsforform <- paste(all_vars, collapse = " + ")
# Change this manually between 'Path' and 'Destination' for now
formula1 <- paste("Destination ~", varsforform)
formulas <- c(list(formula1), formulas)
return(formulas)
}
# Test the function get_formulas
formulaP <- get_formulas(best_destination)
print(formulaP)
# Run the function
# Path
formulaP <- get_formulas(best_path)
print(formulaP)
# Run the function - remember to change manually between path and destination for now
# Path
formulaP <- get_formulas(best_path)
print(formulaP)
# It returns a list of character strings, not actual formulas, so turn it to formulas
formula_listP <- lapply(formulaP, as.formula)
formula_listD <- lapply(formulaD, as.formula)
get_formulas <- function(causevector) {
state_names = names(causevector)
vars <- state_names[causevector != 0]
singles <- vars[nchar(vars) == 1]
interactions <- vars[nchar(vars) == 2]
formulas <- list()
# This next 'if' section gets the edges between single vars and interaction vars
# If there is at least one interaction var and single vars, then for each interaction var have a formula where the interaction var predicts its constituent single vars
if (length(interactions) > 0 & length(singles) > 0)
{
for (int_var in interactions) {
constituents <- unlist(strsplit(int_var, split = ""))
for (constituent in constituents) {
if (constituent %in% singles) {
formula <- paste(int_var, "~", constituent)
formulas <- c(formulas, list(formula))
}
}
}
}
# if (length(vars) > 1) {
#   for (i in 1:(length(vars) - 1)) {
#     from_var <- vars[i]
#     to_var <- vars[i + 1]
#     formula <- paste(to_var, "~", from_var)
#     formulas <- c(formulas, list(formula))
#   }
# }
vars_u <- paste0(vars, "u")
# Anything in causevector, plus its unobserved counterpart, goes to Path
all_vars <- c(vars, vars_u)
varsforform <- paste(all_vars, collapse = " + ")
# Change this manually between 'Path' and 'Destination' for now
formula1 <- paste("Destination ~", varsforform)
formulas <- c(list(formula1), formulas)
return(formulas)
}
# Destination
formulaD <- get_formulas(best_destination)
print(formulaD)
# It returns a list of character strings, not actual formulas, so turn it to formulas
formula_listP <- lapply(formulaP, as.formula)
formula_listD <- lapply(formulaD, as.formula)
View(formula_listD)
View(formula_listP)
get_formulas <- function(causevector) {
state_names = names(causevector)
vars <- state_names[causevector != 0]
singles <- vars[nchar(vars) == 1]
interactions <- vars[nchar(vars) == 2]
formulas <- list()
# This next 'if' section gets the edges between single vars and interaction vars
# If there is at least one interaction var and single vars, then for each interaction var have a formula where the interaction var predicts its constituent single vars
if (length(interactions) > 0 & length(singles) > 0)
{
for (int_var in interactions) {
constituents <- unlist(strsplit(int_var, split = ""))
for (constituent in constituents) {
if (constituent %in% singles) {
formula <- paste(int_var, "~", constituent)
formulas <- c(formulas, list(formula))
}
}
}
}
# if (length(vars) > 1) {
#   for (i in 1:(length(vars) - 1)) {
#     from_var <- vars[i]
#     to_var <- vars[i + 1]
#     formula <- paste(to_var, "~", from_var)
#     formulas <- c(formulas, list(formula))
#   }
# }
vars_u <- paste0(vars, "u")
# Anything in causevector, plus its unobserved counterpart, goes to Path
all_vars <- c(vars, vars_u)
varsforform <- paste(all_vars, collapse = " + ")
# Change this manually between 'Path' and 'Destination' for now
formula1 <- paste("Path ~", varsforform)
formulas <- c(list(formula1), formulas)
return(formulas)
}
# Run the function - remember to change manually between path and destination for now
# Path
formulaP <- get_formulas(best_path)
print(formulaP)
# It returns a list of character strings, not actual formulas, so turn it to formulas
formula_listP <- lapply(formulaP, as.formula)
View(formula_listP)
dagP <- do.call(dagify, formula_listP)
install.packages('ggdag')
install.packages('dagitty')
renv::snapshot()
dagP <- do.call(dagify, formula_listP)
library(ggdag)
library(dagitty)
dagP <- do.call(dagify, formula_listP)
# Now analyse or plot this with ggdag or dagitty
tidy_dag <- tidy_dagitty(dagP)
ggdag(tidy_dag)  # Then add ggplot2 layers for more customisation
#------------- PATH -------------------
dagP <- do.call(dagify, formula_listP)
# Set coordinates immediately after creating `dagP`
coordinates(dagP) <- list(
x = c(K = 0, Ku = -0.5, KS = 1, KSu = 1.5, Path = 0.5),
y = c(K = 2, Ku = 1.5, KS = 2, KSu = 1.5, Path = 0)
)
tidy_dagP <- tidy_dagitty(dagP)
ggdag(tidy_dagP) + remove_axes() # try with axes to get the coords first thenr emove
best_path
best_destination_params
View(fitted_path_params)
View(tmp)
mean(fitted_path_mods$n_edge)
# Btw, some reporting stats about this distribution:
mean(fitted_path_mods$kl) # 0.78
sd(fitted_path_mods$kl) # 0.26
mean(fitted_destination_mods$kl) # 0.83
sd(fitted_destination_mods$kl) # 0.27
mean(fitted_path_mods$n_edge)
sd(fitted_path_mods$n_edge)
mean(fitted_destination_mods$n_edge)
sd(fitted_destination_mods$n_edge)
# Find which model has the lowest KL divergence - that's the one we want!
which.min(fitted_path_mods$kl) # 31717 for first td but redone as 32204 - no - 25874
min(fitted_path_mods$kl)
which.min(fitted_destination_mods$kl) # 58713
min(fitted_destination_mods$kl) # .0092
# Make the KL bigger for each edge so to penalise complexity and so avoid saturated fully connected model
bpix <- which.min(fitted_path_mods$kl + fitted_path_mods$n_edge*complexity_penalisation) # 22967
bdix <- which.min(fitted_destination_mods$kl + fitted_destination_mods$n_edge*complexity_penalisation) # 58713
best_path_params
best_path_params[2:11]
# Make a composite variable which adds the part of best_path_params whose names match those in best_path, to get a var of names, then its best path values and also those parameters
pathmod <- rbind(best_path, best_path_params[2:11])
View(pathmod)
pathmod <- rbind(best_path, best_path_params)
best_path_params %in% best_path
best_path
best_path_params
pathmod <- rbind(best_path, best_path_params[2:11])
View(pathmod)
# Find the best fitting structures and their parameters
best_path <- unlist(structures[bpix,]) # 00100-10000 - no - 01000000-10
best_path_params <- unlist(fitted_path_mods[bpix,])
