library(here)
load(here('Exp1Prediction', 'Model', 'Data', 'model.rda'))
source(here('Exp1Prediction', 'Model', 'Scripts', 'modelUtils.R'))
# Load fitted models from `01findModel.R`: 2 dfs of 59049 rows of 13 vars each: path and destination
load(here('Exp1Prediction', 'Model', 'Data', 'fitted.rda'))
load(here('Exp1Prediction', 'Model', 'Data', 'targetDist.rda')) # from before - still need those
# Sometimes use this before we can get it out of the long brute force causal model selection
situations <- as.factor(td_sd$Situation)
# ---------- Rename destination to food -------------
# Just makes it simpler later
fitted_food_mods <- fitted_destination_mods # rename everywhere! Simpler to do it earlier rather than later
# Count number of edges in each structure
fitted_path_mods$n_edge <- rowSums(structures!=0)
fitted_food_mods$n_edge <- rowSums(structures!=0)
# Penalise complexity (number of edges) to avoid overfitting
complexity_penalisation <- 0.003 # Tried variety, see below, settled on .003 as both path and dest have become stable there
# Make the KL bigger for each edge so to penalise complexity and so avoid saturated fully connected model
bpix <- which.min(fitted_path_mods$kl + fitted_path_mods$n_edge*complexity_penalisation) # 22967
bfix <- which.min(fitted_food_mods$kl + fitted_food_mods$n_edge*complexity_penalisation) # 58713
# Btw, some reporting stats about this distribution:
mean(fitted_path_mods$kl) # .43
sd(fitted_path_mods$kl) # .17
mean(fitted_food_mods$kl) # .21
sd(fitted_food_mods$kl) # .08
mean(fitted_path_mods$n_edge) # 6.7
sd(fitted_path_mods$n_edge) # 1.5
mean(fitted_food_mods$n_edge) # 6.7
sd(fitted_food_mods$n_edge) # 1.5
# Find the best fitting structures and their parameters
best_path <- unlist(structures[bpix,]) # 01000000-10
best_path_params <- unlist(fitted_path_mods[bpix,])
best_food <- unlist(structures[bfix,]) # 1 0 0 0 0 0 1 0 1 1
best_food_params <- unlist(fitted_food_mods[bfix,])
# Get model predictions for each situation
tmp <- fitted_path_mods[bpix,] # There must be a better way because these are basically the same but best_path_params is unlisted?!
# The function wants a list with s as a named vector of the 10 strengths, and only then br and tau
fitted_path_params <- list(s = c(P = tmp$P,
K = tmp$K,
C = tmp$C,
S = tmp$S,
PK=tmp$PK,
PC=tmp$PC,
PS=tmp$PS,
KC=tmp$KC,
KS=tmp$KS,
CS=tmp$CS),
br = tmp$br,
tau = tmp$tau)
tmp <- fitted_food_mods[ bfix,]
fitted_food_params <- list(s = c(P = tmp$P,
K = tmp$K,
C = tmp$C,
S = tmp$S,
PK=tmp$PK,
PC=tmp$PC,
PS=tmp$PS,
KC=tmp$KC,
KS=tmp$KS,
CS=tmp$CS),
br = tmp$br,
tau = tmp$tau)
# Call function 1 from `modelUtils` file
mpp <- get_mod_pred(structures[bpix,], fitted_path_params)
mpf <- get_mod_pred(structures[bfix,], fitted_food_params)
df.m <- data.frame(situation = situations,
td_path = td_path,
td_food = td_destination,
mp_path = mpp,
mp_food = mpf)
# Get the 'active' edges from best_path: the ones !=0 and their corresponding parameters
active_path_edges <- names(best_path)[best_path != 0]
active_path_params <- best_path_params[active_path_edges]
# Wrap these together into a named vector
active_path <- setNames(active_path_params, active_path_edges)
active_path
# And the same for food
active_food_edges <- names(best_food)[best_food != 0]
active_food_params <- best_food_params[active_food_edges]
# Wrap these together into a named vector
active_food <- setNames(active_food_params, active_food_edges)
active_food
# Results in 2 dfs, each of 59049 obs of 13 vars
save(df.m,
best_path,
best_path_params,
best_food,
best_food_params,
active_food,
active_path,
mpp,
mpf,
file = here('Exp1Prediction', 'Model', 'Data', 'model.rda'))
load(here('Exp1Prediction', 'Model', 'Data', 'model.rda'))
load(here('Exp1Prediction', 'Model', 'Data', 'targetDist.rda')) #
View(td_sd)
View(td_combined)
View(td)
library(tidyverse)
library(kableExtra)
library(here)
# Load df 1421 of 27. Each row is one participant's response to one of the 16 situations. Was 1440 but 19 had 0s so were removed.
load(here('Exp1Prediction', 'Experiment', 'Data', 'gwExp1data.Rda'))
# Get the complete target distribution over all outcomes: 16 of 5, then lose first column
td <- df |>
group_by(Situation) |>
summarise(p_short_pizza = mean(p_short_pizza, na.rm=T),
p_long_pizza = mean(p_long_pizza, na.rm=T),
p_short_hotdog = mean(p_short_hotdog, na.rm=T),
p_long_hotdog = mean(p_long_hotdog, na.rm=T)) |>
data.frame()
# Print a latex table of the means
kable(td,
format = "latex",
digits = 3,
caption = "Target Distributions by Situation",
col.names = c("Situation", "Short Pizza", "Long Pizza", "Short Hotdog", "Long Hotdog"))
td <- td[,2:5] # 16 obs of 4
# A new df like td but to get sd instead
td_sd <- df |>
group_by(Situation) |>
summarise(sd_short_pizza = sd(p_short_pizza, na.rm=T),
sd_long_pizza = sd(p_long_pizza, na.rm=T),
sd_short_hotdog = sd(p_short_hotdog, na.rm=T),
sd_long_hotdog = sd(p_long_hotdog, na.rm=T)) |>
data.frame()
# Print a latex table of the sds
kable(td_sd,
format = "latex",
digits = 3,
caption = "Standard Deviations by Situation",
col.names = c("Situation", "Short Pizza", "Long Pizza", "Short Hotdog", "Long Hotdog"))
# A combined latex table of means and sds for reporting the descriptives of Exp1
td_combined <- data.frame(
Situation = 1:16,
Short_Pizza_Mean = td$p_short_pizza,
Short_Pizza_SD = td_sd$sd_short_pizza,
Long_Pizza_Mean = td$p_long_pizza,
Long_Pizza_SD = td_sd$sd_long_pizza,
Short_Hotdog_Mean = td$p_short_hotdog,
Short_Hotdog_SD = td_sd$sd_short_hotdog,
Long_Hotdog_Mean = td$p_long_hotdog,
Long_Hotdog_SD = td_sd$sd_long_hotdog
)
# Calculate marginal probabilities for path and destination
td_path <- (df |>
group_by(Situation) |>
summarise(p_long = mean(p_long, na.rm=T)))$p_long
td_destination <- (df |>
group_by(Situation) |>
summarise(p_hotdog = mean(p_hotdog, na.rm=T)))$p_hotdog
# A new var for later
situations <- df$SituationVerbose[1:16]
# Save target distributions for later modelling
save(td,
td_sd,
td_combined,
td_path,
td_destination,
situations,
file = here('Exp1Prediction', 'Model', 'Data', 'targetDist.rda'))
##########################
##### Congruency ########
# Congruency is how well the action fits or is aligned with the starting conditions
# E.g., if you see pizza, and you are lazy and have no preference, then going short to pizza is congruent
# If all actions have a 0.25 probability, then none is particularly congruent, or any more congruent than the others
# If one action has a high probability, then it is congruent, and if it has low then it is incongruent
# However deciding the cut-off numbers for congruent and incongruent is tricky: presumably as high as .4 or .5 should def be congruent
print(max(td$p_long_hotdog)) # .30
print(max(td$p_short_pizza)) # .48
print(max(td$p_long_pizza)) # .26
print(max(td$p_short_hotdog)) # .52
print(min(td$p_long_hotdog)) # .11
print(min(td$p_short_pizza)) # .18
print(min(td$p_long_pizza)) # .10
print(min(td$p_short_hotdog)) # .26
# Because these are normalised, they are all rather wishy washy and often don't give a clear signal.
# Long pizza never seems very high and short hotdog is relatively highly congruent in every situation
# (If the definition of congruency is just how likely their action was). Possibly park this for a bit
# It doesn't make sense to give a hard 1:4 allocation for the 4 actions on each row.
# (That would mean an action could be most congruent (1) with a p_action of almost same as the one with (4).
# But also don't want an absolute marker?
load(here('Exp1Prediction', 'Model', 'Data', 'model.rda'))
load(here('Exp1Prediction', 'Model', 'Data', 'targetDist.rda')) #
best_food_params
best_path_params
View(df.m)
View(df.m)
View(td)
View(td_sd)
df.m <- data.frame(situation = situations,
td_path = td_path,
td_food = td_destination,
mp_path = mpp,
mp_food = mpf)
View(df.m)
View(td_sd)
load(here('Exp1Prediction', 'Experiment', 'Data', 'gwExp1data.Rda'))
# ==============================================================================
# Obtaining target distributions
# ==============================================================================
# This script summarises experimental data from a path/destination choice task where
# participants rated the likelihood of different routes and destinations based on
# various factors:
#
# Variables:
# - P (Preference): Whether the person has a food preference (0=Absent, 1=Hotdog)
# - K (Knowledge): Whether they know about the hotdog stand (0=No, 1=Yes)
# - C (Character): Person's character type (0=Lazy, 1=Sporty)
# - S (Start): What's visible at the start (0=See_pizza, 1=See_hotdog)
#
# The script:
# 1. Loads and preprocesses experimental data
# 2. Summarises target distributions for each of the 16 situations (mean and sd)
# 3. Generates latex tables for reporting
# ==============================================================================
## Calculate Target Distributions
# ==============================================================================
# Get the complete target distribution over all outcomes: 16 of 5, then lose first column
td <- df |>
group_by(Situation) |>
summarise(p_short_pizza = mean(p_short_pizza, na.rm=T),
p_long_pizza = mean(p_long_pizza, na.rm=T),
p_short_hotdog = mean(p_short_hotdog, na.rm=T),
p_long_hotdog = mean(p_long_hotdog, na.rm=T)) |>
data.frame()
# Print a latex table of the means
kable(td,
format = "latex",
digits = 3,
caption = "Target Distributions by Situation",
col.names = c("Situation", "Short Pizza", "Long Pizza", "Short Hotdog", "Long Hotdog"))
td <- td[,2:5] # 16 obs of 4
# A new df like td but to get sd instead
td_sd <- df |>
group_by(Situation) |>
summarise(sd_short_pizza = sd(p_short_pizza, na.rm=T),
sd_long_pizza = sd(p_long_pizza, na.rm=T),
sd_short_hotdog = sd(p_short_hotdog, na.rm=T),
sd_long_hotdog = sd(p_long_hotdog, na.rm=T)) |>
data.frame()
# Print a latex table of the sds
kable(td_sd,
format = "latex",
digits = 3,
caption = "Standard Deviations by Situation",
col.names = c("Situation", "Short Pizza", "Long Pizza", "Short Hotdog", "Long Hotdog"))
# A combined latex table of means and sds for reporting the descriptives of Exp1
td_combined <- data.frame(
Situation = 1:16,
Short_Pizza_Mean = td$p_short_pizza,
Short_Pizza_SD = td_sd$sd_short_pizza,
Long_Pizza_Mean = td$p_long_pizza,
Long_Pizza_SD = td_sd$sd_long_pizza,
Short_Hotdog_Mean = td$p_short_hotdog,
Short_Hotdog_SD = td_sd$sd_short_hotdog,
Long_Hotdog_Mean = td$p_long_hotdog,
Long_Hotdog_SD = td_sd$sd_long_hotdog
)
# Calculate marginal probabilities for path and destination
td_path <- (df |>
group_by(Situation) |>
summarise(p_long = mean(p_long, na.rm=T)))$p_long
td_destination <- (df |>
group_by(Situation) |>
summarise(p_hotdog = mean(p_hotdog, na.rm=T)))$p_hotdog
# A new var for later
situationsVerbose <- df$SituationVerbose[1:16]
situations <- as.factor(td_sd$Situation)
# Save target distributions for later modelling
save(td,
td_sd,
td_combined,
td_path,
td_destination,
situationsVerbose,
situations,
file = here('Exp1Prediction', 'Model', 'Data', 'targetDist.rda'))
##########################
##### Congruency ########
# Congruency is how well the action fits or is aligned with the starting conditions
# E.g., if you see pizza, and you are lazy and have no preference, then going short to pizza is congruent
# If all actions have a 0.25 probability, then none is particularly congruent, or any more congruent than the others
# If one action has a high probability, then it is congruent, and if it has low then it is incongruent
# However deciding the cut-off numbers for congruent and incongruent is tricky: presumably as high as .4 or .5 should def be congruent
load(here('Exp1Prediction', 'Model', 'Data', 'targetDist.rda')) # from before - still need those
source(here('Exp1Prediction', 'Model', 'Scripts', 'modelUtils.R'))
# Load fitted models from `01findModel.R`: 2 dfs of 59049 rows of 13 vars each: path and destination
load(here('Exp1Prediction', 'Model', 'Data', 'fitted.rda'))
# ---------- Rename destination to food -------------
# Just makes it simpler later
fitted_food_mods <- fitted_destination_mods # rename everywhere! Simpler to do it earlier rather than later
# Count number of edges in each structure
fitted_path_mods$n_edge <- rowSums(structures!=0)
fitted_food_mods$n_edge <- rowSums(structures!=0)
# -------- Complexity penalisation -------------
# Penalise complexity (number of edges) to avoid overfitting
complexity_penalisation <- 0.003 # Tried variety, see below, settled on .003 as both path and dest have become stable there
# With complexity 0
# bpix was 25874 which gives structure 0, 1, -1, 0, 0, 0, 1, 1, -1, 0
# bdix was 58713 which gives structure 1, 0, 0, 1, 0, 0, 1, 1, 1, 1
# With complexity .001
# bpix was 31679 which gives structure 0  1 -1 -1  0  0  0  1  0  0
# bdix was 58713 which gives structure 1  0  0  1  0  0  1  1  1  1
# With complexity .002
# bpix was 22967 which gives structure 0  1  0  0  0  0  0  0 -1  0
# bdix was 58713 which gives structure 1  0  0  1  0  0  1  1  1  1
# With complexity .003
# bpix was 22967 which gives structure 0  1  0  0  0  0  0  0 -1  0 same as at .002
# bdix was 56499 which gives structure 1  0  0  0  0  0  1  0  1  1 few less edges
# With complexity .004
# bpix was 22967 which gives structure 0  1  0  0  0  0  0  0 -1  0
# bdix was 56499 which gives structure 1  0  0  0  0  0  1  0  1  1
# Make the KL bigger for each edge so to penalise complexity and so avoid saturated fully connected model
bpix <- which.min(fitted_path_mods$kl + fitted_path_mods$n_edge*complexity_penalisation) # 22967
bfix <- which.min(fitted_food_mods$kl + fitted_food_mods$n_edge*complexity_penalisation) # 58713
# Btw, some reporting stats about this distribution:
mean(fitted_path_mods$kl) # .43
sd(fitted_path_mods$kl) # .17
mean(fitted_food_mods$kl) # .21
sd(fitted_food_mods$kl) # .08
mean(fitted_path_mods$n_edge) # 6.7
sd(fitted_path_mods$n_edge) # 1.5
mean(fitted_food_mods$n_edge) # 6.7
sd(fitted_food_mods$n_edge) # 1.5
# Find the best fitting structures and their parameters
best_path <- unlist(structures[bpix,]) # 01000000-10
best_path_params <- unlist(fitted_path_mods[bpix,])
# rbind best_path and the params that have a name in best_path
#pathmod <- rbind(best_path, best_path_params[2:11])
# Get the names of best_path_params that are in best_path
best_food <- unlist(structures[bfix,]) # 1 0 0 0 0 0 1 0 1 1
best_food_params <- unlist(fitted_food_mods[bfix,])
# Get model predictions for each situation
tmp <- fitted_path_mods[bpix,] # There must be a better way because these are basically the same but best_path_params is unlisted?!
# The function wants a list with s as a named vector of the 10 strengths, and only then br and tau
fitted_path_params <- list(s = c(P = tmp$P,
K = tmp$K,
C = tmp$C,
S = tmp$S,
PK=tmp$PK,
PC=tmp$PC,
PS=tmp$PS,
KC=tmp$KC,
KS=tmp$KS,
CS=tmp$CS),
br = tmp$br,
tau = tmp$tau)
tmp <- fitted_food_mods[ bfix,]
fitted_food_params <- list(s = c(P = tmp$P,
K = tmp$K,
C = tmp$C,
S = tmp$S,
PK=tmp$PK,
PC=tmp$PC,
PS=tmp$PS,
KC=tmp$KC,
KS=tmp$KS,
CS=tmp$CS),
br = tmp$br,
tau = tmp$tau)
# Call function 1 from `modelUtils` file. mpp and mpf are the marginal probabilities for pathLong and foodHotdog
mpp <- get_mod_pred(structures[bpix,], fitted_path_params)
mpf <- get_mod_pred(structures[bfix,], fitted_food_params)
df.m <- data.frame(situation = situations,
td_path = td_path,
td_food = td_destination,
mp_path = mpp,
mp_food = mpf)
# Get the 'active' edges from best_path: the ones !=0 and their corresponding parameters
active_path_edges <- names(best_path)[best_path != 0]
active_path_params <- best_path_params[active_path_edges]
# Wrap these together into a named vector
active_path <- setNames(active_path_params, active_path_edges)
# And the same for food
active_food_edges <- names(best_food)[best_food != 0]
active_food_params <- best_food_params[active_food_edges]
# Wrap these together into a named vector
active_food <- setNames(active_food_params, active_food_edges)
# Results in 2 dfs, each of 59049 obs of 13 vars
save(df.m,
best_path,
best_path_params,
best_food,
best_food_params,
active_food,
active_path,
mpp,
mpf,
file = here('Exp1Prediction', 'Model', 'Data', 'model.rda'))
df.m <- data.frame(situationVerbose - situationsVerbose,
situation = situations,
td_path = td_path,
td_food = td_destination,
mp_path = mpp,
mp_food = mpf)
df.m <- data.frame(situationVerbose = situationsVerbose,
situation = situations,
td_path = td_path,
td_food = td_destination,
mp_path = mpp,
mp_food = mpf)
# Get the 'active' edges from best_path: the ones !=0 and their corresponding parameters
active_path_edges <- names(best_path)[best_path != 0]
active_path_params <- best_path_params[active_path_edges]
# Wrap these together into a named vector
active_path <- setNames(active_path_params, active_path_edges)
# And the same for food
active_food_edges <- names(best_food)[best_food != 0]
active_food_params <- best_food_params[active_food_edges]
# Wrap these together into a named vector
active_food <- setNames(active_food_params, active_food_edges)
# Results in 2 dfs, each of 59049 obs of 13 vars
save(df.m,
best_path,
best_path_params,
best_food,
best_food_params,
active_food,
active_path,
mpp,
mpf,
file = here('Exp1Prediction', 'Model', 'Data', 'model.rda'))
load(here('Exp1Prediction', 'Model', 'Data', 'model.rda'))
View(df.m)
# We need to combine these to get p for each of the 4 choices in each situation
# First expand df.m to a df of 16x4 = 64 rows
pChoice <- df.m %>%
slice(rep(1:n(), each = 4)) %>%
mutate(Choice = rep(c("Pizza", "Hotdog", "Pizza", "Hotdog"), times = n()/4),
Path = rep(c("Short", "Short", "
Long", "Long"), times = n()/4))
View(pChoice)
# We need to combine these to get p for each of the 4 choices in each situation
# First expand df.m to a df of 16x4 = 64 rows
pChoice <- df.m %>%
slice(rep(1:n(), each = 4)) %>%
mutate(Path = rep(c("Short", "Short", "Long", "Long"), times = n()/4),
Food = rep(c("Pizza", "Hotdog", "Pizza", "Hotdog"), times = n()/4))
View(pChoice)
View(pChoice)
View(df.m)
# We need to combine these to get p for each of the 4 choices in each situation
# Make a df of all 16 situations
pChoice <- data.frame(situation = rep(df.m$situation, each=4),
Food = rep(c("Pizza", "Pizza", "Hotdog", "Hotdog"), times=nrow(df.m)),
Path = rep(c("Short", "Long", "Short", "Long"), times=nrow(df.m))
)
View(pChoice)
View(df.m)
View(pChoice)
# We need to combine these to get p for each of the 4 choices in each situation
# Make a df of all 16 situations
pChoice <- data.frame(situationVerbose = rep(df.m$situatioVerbose, each=4),
situation = rep(df.m$situation, each=4),
Food = rep(c("Pizza", "Pizza", "Hotdog", "Hotdog"), times=nrow(df.m)),
Path = rep(c("Short", "Long", "Short", "Long"), times=nrow(df.m))
)
# We need to combine these to get p for each of the 4 choices in each situation
# Make a df of all 16 situations
pChoice <- data.frame(situationVerbose = rep(df.m$situationVerbose, each=4),
situation = rep(df.m$situation, each=4),
Food = rep(c("Pizza", "Pizza", "Hotdog", "Hotdog"), times=nrow(df.m)),
Path = rep(c("Short", "Long", "Short", "Long"), times=nrow(df.m))
)
View(pChoice)
pChoice <- pChoice |>
mutate(fullSituation = paste0(situation,
ifelse(Food == "Pizza", "0", "1"),
ifelse(Path == "Short", "0", "1")))
View(pChoice)
View(df.m)
View(pChoice)
probs <- df.m %>%
mutate(p_short = 1 - mp_path,
p_long = mp_path,
p_hotdog = mp_food,
p_pizza = 1 - mp_food)
View(probs)
probs <- df.m |>
mutate(p_short = 1 - mp_path,
p_long = mp_path,
p_hotdog = mp_food,
p_pizza = 1 - mp_food) |>
select(situation, p_short, p_long, p_hotdog, p_pizza)
View(probs)
# Merge probs to pChoice
pChoice <- merge(pChoice, probs, by="situation")
# Now pChoice has p_short, p_long, p_hotdog, p_pizza for each row
# Now calculate p_action for each row
pChoice <- pChoice |>
mutate(p_action = ifelse(Food == "Pizza" & Path == "Short", p_short * p_pizza,
ifelse(Food == "Pizza" & Path == "Long", p_long * p_pizza,
ifelse(Food == "Hotdog" & Path == "Short", p_short * p_hotdog,
p_long * p_hotdog))))
View(pChoice)
# check they sum to 1
pChoice |>
group_by(situation) |>
summarise(sum=sum(p_action))
View(pChoice)
str(pChoice)
# save Food, Path and Situation as factors
pChoice <- pChoice |>
mutate(Food = factor(Food, levels=c("Pizza", "Hotdog")),
Path = factor(Path, levels=c("Short", "Long")),
fullSituation = factor(fullSituation, levels=unique(fullSituation)))
str(pChoice)
# save pChoice
save(pChoice, file=here('Exp2Explanation', 'Model', 'Data', 'pChoice.rda'))
i
# save pChoice
save(pChoice, file=here('Exp2Explanation', 'Model', 'Data', 'pChoice.rda'))
