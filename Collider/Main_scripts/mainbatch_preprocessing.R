#################################################### 
###########  Collider analysis pilot   #############
####################################################

# Script for putting together the batches of participants, data collected 4 July 2024 (test and main)
# Based on existing script `pilot_preprocessing` 
# (there were 5 before with differnet data structure, needing different preprocessing, they are also brought in here)
# Then saves big data df, and also that data split out into the three probability groups

library(tidyverse)
library(rjson)
rm(list=ls())


# ---------- Get main data -----------
# Setwd for main data
setwd("../Data/batch") # as in, setwd("/Users/stephaniedroop/Documents/GitHub/gw/Collider/Data/batch")

# read in csvs 
csvList <- lapply(list.files("./"), read.csv, stringsAsFactors = F) # this gives list of 10 when you're in the wd
# csvList <- lapply(list.files("./pilot_data"), read.csv, stringsAsFactors = F)
# bind them 
dataset <- do.call(rbind, csvList) # 6650 obs of 20 vars

# Data rows were generated by different trials, but we can get everything we need in one row
# But first we need to replace spaces with NA
dataset <- dataset %>% mutate(across(c('answer'), ~na_if(.,"")))
# Then can fill upwards to get the text answer in the same place as the trial info
dataset <- dataset %>% fill(answer, .direction = 'up')

# ---------- Get jsons of static worlds info used in experiment ------
# Get the jsons
worlds <- fromJSON(file = '../../Experiment/worlds.json')
worldsdf <- as.data.frame(worlds) # 8 obs of 132 vars
conds <- fromJSON(file = '../../Experiment/conds.json')
condsdf <- as.data.frame(conds) # 2 obs of 21 vars 

# ------------ Get pilot data -------------
# Setwd 
setwd("../../pilot_data") # as in, setwd("/Users/stephaniedroop/Documents/GitHub/gw/Collider/pilot_data")

# read in csvs 
csvList <- lapply(list.files("./"), read.csv, stringsAsFactors = F) # this gives list of 10 when you're in the wd
# csvList <- lapply(list.files("./pilot_data"), read.csv, stringsAsFactors = F)
# bind them 
dataset2 <- do.call(rbind, csvList) # 250 of 20

# Get the feedback rows and comment out - THIS WAS PILOT ONLY
# feedback <- dataset[dataset$rowtype=='feedback',]

# Data rows were generated by different trials, but we can get everything we need in one row
# But first we need to replace spaces with NA
dataset2 <- dataset2 %>% mutate(across(c('answer'), ~na_if(.,"")))
# Then can fill upwards to get the text answer in the same place as the trial info
dataset2 <- dataset2 %>% fill(answer, .direction = 'up')

# --------- Get the first five pilot data -------------
pilot5 <- read.csv('../processed_data/pilot1.csv') %>% select(-(c(1,14,15)))

# Put them together
dataset <- rbind(dataset,dataset2)

# ---------- Now analysing all data together ---------
# 6950 obs of 15

# Remove empty cols and rows
dataset <- dataset %>% filter(cb!='NA') # Obs should be 12* no. of ppts, as each did 12 trials. 3509 of 13

# Here 3329 of 13 vars, so some did not complete. Find who is complete
s12 <- dataset %>% group_by(prolific_id) %>% summarise(n=n()) # 294
keep <- filter(s12,n==12) # 279
dataset <- dataset %>% filter(prolific_id %in% keep$prolific_id) # 3348

# NOW can remove the cols with long strings, and rbind with the pilot2 data (which we checked was complete at the time)
dataset <- dataset %>% select(-c(2:4,6,7))
dataset <- dataset %>% select(-c(13:14))

dataset <- rbind(dataset, pilot5) # 3408

# Put a column with structure - for some reason it doesn't have
data <- dataset %>% mutate(structure = if_else(grepl("^c", trialtype), 'conjunctive', 'disjunctive'))


# --------------- Processing the answers participants gave -----------------

# Now reattach the number of their answer, as atm it has only recorded the text on their radio button
# First here are the arrays of possible buttons from js exp.
jobanswers <- c('The candidate had skill A',
            'The candidate did not have skill A',
            'The candidate demonstrated skill A',
            'The candidate did not demonstrate skill A',
            'The candidate had skill B',
            'The candidate did not have skill B',
            'The candidate demonstrated skill B',
            'The candidate did not demonstrate skill B')

cookanswers <- c('The chef completed the main dish',
                 'The chef did not complete the main dish',
                 'The main dish impressed the panel',
                 'The main dish did not impress the panel',
                 'The chef completed the dessert',
                 'The chef did not complete the dessert',
                 'The dessert impressed the panel',
                 'The dessert did not impress the panel')

groupanswers <- c('The lecturer attended',
                  'The lecturer did not attend',
                  'The lecturer talked about the paper',
                  'The lecturer did not talk about the paper',
                  'The postdoc attended',
                  'The postdoc did not attend',
                  'The postdoc talked about the paper',
                  'The postdoc did not talk about the paper')

# Now make a new column with the position in array of their answer
data <- data %>% mutate(ans = if_else(scenario=='job', match(data$answer, jobanswers), 
                                    if_else(scenario=='cook', match(data$answer, cookanswers),
                                            match(data$answer, groupanswers))))


# There is one(!) cell in the data that stubbornly keep putting NA, even though I can see a legal answer in the original data
# No idea why. I am replacing manually 
data[2861,15] <- 4


# ------------ The long road to reversing the counterbalancing -------------------

data0 <- data %>% filter(cb==0)
data1 <- data %>% filter(cb==1)

# HOLD EVERYTHING WHILE I GO TO ANOTHER SCRIPT AND SOLVE THIS
#write.csv(data1, '../data1.csv')

# also need to mix around some actual conditions

# I think for c1,c4, c5, d1, d6, d7, we can just switch the answers
# But for the others, for TRIALTYPE, they have to be changed as follows:
# c2 goes to c3
# c3 goes to c2
# d2 goes to d4
# d3 goes to d5
# d4 goes to d2
# d5 goes to d3

# To do this, we'll take an intermediate column and then start replacing values
data1$cbtt <- data1$trialtype
data1$cbtt[data1$trialtype=='c2'] <- 'c3'
data1$cbtt[data1$trialtype=='c3'] <- 'c2'
data1$cbtt[data1$trialtype=='d2'] <- 'd4'
data1$cbtt[data1$trialtype=='d3'] <- 'd5'
data1$cbtt[data1$trialtype=='d4'] <- 'd2'
data1$cbtt[data1$trialtype=='d5'] <- 'd3'


# Now we can flip all the answers
# Store indices of which answers are already a and which are b
aans <- as.vector(1:4)
bans <- as.vector(5:8)

# Create new var where they are flipped
data1$intans <- data1$ans 
data1 <- data1 %>% mutate(anscb = if_else(ans %in% aans, intans+4, intans-4))
data1 <- data1 %>% select(-c(trialtype,ans)) %>% rename(trialtype = cbtt, ans = anscb)

# Now rearrange the cols we need
data1 <- data1 %>% select(1:6,13,14,16)
data0 <- data0 %>% select(1:6,14,13,15)

data <- rbind(data0,data1) # 3456 of 9

# Map the answers they gave to the variables, in three increasing levels of granularity

# 1. Just the 4 variables, irrespective of the value they took
data <- data %>% mutate(ansVar = if_else(ans==1|ans==2, 'A', 
                                         if_else(ans==3|ans==4, 'Au',
                                                 if_else(ans==5|ans==6, 'B', 'Bu'))))

# 2. Six values, ie A and B are observed so don't need options, but unobserved Au and Bu can take either value
data <- data %>% mutate(ansVar2 = if_else(ans==1|ans==2, 'A', 
                                          if_else(ans==3, 'Au=1',
                                                  if_else(ans==4, 'Au=0',
                                                          if_else(ans==5|ans==6, 'B', 
                                                                  if_else(ans==7, 'Bu=1', 'Bu=0'))))))
# 3. Eight values: each var can take either value
data <- data %>% mutate(ansVar3 = if_else(ans==1, 'A=1',
                                          if_else(ans==2, 'A=0',
                                                  if_else(ans==3, 'Au=1',
                                                          if_else(ans==4, 'Au=0',
                                                                  if_else(ans==5, 'B=1', 
                                                                          if_else(ans==6, 'B=0',
                                                                                  if_else(ans==7, 'Bu=1', 'Bu=0'))))))))



# -------- Permissable actual cause analysis -----------
# Checks whether ppt's answers are permissable as per Tadeg's (via Halpern) actual causation condition
# NOTE: the var "possAns" is indexed 1:8 and was stored in worlds only for this, not for any use in javascript

# Get .possAns out of json 
js <- worldsdf %>% select(ends_with("possAns"))

# Remove .possAns string from colnames, transpose so easier to search and add 1 to every cell because js indexes from 0
colnames(js) <- sub(".possAns", "", colnames(js))
js <- t(js)

# Empty vec to put the answers in, same order and size as
isPerm <- rep(NA, 3408) # Replace later - 3456 - I removed the cb=1 for a test

# (Long winded index match - would be good to know a better way)
for (k in 1:nrow(data)) 
{
  row <- data[k,]
  ttype <- row$trialtype
  ans <- row$ans
  jsvec <- js[ttype,1:8]
  isposs <- ans %in% jsvec
  isPerm[k] <- isposs
}
# Add to df1 (I checked it is right)
data <- cbind(data, isPerm)

# Now group by ppt to see if they mostly pick permissable answers. groupby subjectID first to see who is at it
tf <- data %>% group_by(isPerm) %>% summarise(n=n()) # They do

# -------- Coherent cause analysis -----------
# Checks whether ppt's answers are COHERENT in context of that situation
# A less stringent version of the previous analysis
# NOTE: the var "cohAns" is indexed 1:8 and was stored in worlds only for this, not for any use in javascript

# Get .cohAns out of json
jc <- worldsdf %>% select(ends_with("cohAns"))

# Remove .cohAns string from colnames, transpose so easier to search
colnames(jc) <- sub(".cohAns", "", colnames(jc))
jc <- t(jc)

# Empty vec to put the answers in, same order and size as
isCoh <- rep(NA, 3408) # Replace later - 3456 - I removed the cb=1 for a test

# (Long winded index match - would be good to know a better way)
for (k in 1:nrow(data))
{
  row <- data[k,]
  ttype <- row$trialtype
  ans <- row$ans
  jsvec <- jc[ttype,1:8]
  iscoh <- ans %in% jsvec
  isCoh[k] <- iscoh
}
# Add to df1 (I checked it is right)
data <- cbind(data, isCoh)

# Now group by ppt to see if they mostly pick permissable answers. Groupby subject id to see who is at it
tc <- data %>% group_by(isCoh) %>% summarise(n=n()) # They do




# ------------ Assign some new variables: pgroup then latent variables
# We now give a variable for probgroup, and then split the data into wee dfs for each one, a controversial decision that may backfire and get changed later
data <- data %>% mutate(pgroup = if_else(prob0=='10%' & prob1=='50%' | prob2=='10%' & prob3=='50%', '1', 
                                         if_else(prob0=='50%' & prob1=='80%' | prob2=='50%' & prob3=='80%', '2', '3')))


# Need an original probgroup to preserve the cb and see how we can compare them, to make sure there wasn't much bias 
# This won't have much meaning if I run a new model predictions for the params because I might need to call its fourth group 4
# (Needs to be series of integers, can't really be eg 7, because the fucntion puts i. Although that might be changeable)
data$pgorig <- data$pgroup 
data$pgorig[data$pgroup==1 & data$cb==1] <- 4
data$pgorig[data$pgroup==2 & data$cb==1] <- 5
data$pgorig[data$pgroup==3 & data$cb==1] <- 6
# And still to do these correlations, not sure how exactly yet...

# Later we might still split out these probgroups

# How often did they select latent variables?
data <- data %>% mutate(isLat = ifelse(ansVar=='Au'|ansVar=='Bu', TRUE, FALSE))

# But there is another more nuanced quality: realLatent...
# Sometimes the values of the unobserved variables can be inferred logically. These are NOT 'realLatent'.
# realLatent is when we genuinely don't know what values the unobserved variables take. (when poss >1 in the function `get_cond_probs`)
# It affects the following situations (easier to point out when it is NOT realLatent, and take the inverse)
# All unobserved are realLatent, except:
# c5: Au and Bu
# d2: Bu
# d3: Bu
# d4: Au
# d5: Au
# d6: Au and Bu

# Now encode those rules by putting FALSE. (Everything else is already correctly determined)
data$realLat <- data$isLat
data$realLat[data$trialtype=='c5'|data$trialtype=='d6'] <- FALSE
data$realLat[data$trialtype=='d2' & data$ansVar=='Bu'] <- FALSE
data$realLat[data$trialtype=='d3' & data$ansVar=='Bu'] <- FALSE
data$realLat[data$trialtype=='d4' & data$ansVar=='Au'] <- FALSE
data$realLat[data$trialtype=='d5' & data$ansVar=='Au'] <- FALSE

# We also want a variable denoting 'connected with var A' (including A and Au) and likewise for B
data <- data %>% mutate(connectedWith = ifelse(ansVar=='A'|ansVar=='Au', 'A', 'B'))

data <- data %>% rename(node3 = ansVar3)

# Do we still wanna group by pgroup?? That's an ongoing question. Also whether to save byppt summary (as per Neil - or is that meaningless for this experiment?)
# Better save the data just in case
write.csv(data, '../Data/pptdata.csv') 

save(data, file="../Data/Data.Rdata")
