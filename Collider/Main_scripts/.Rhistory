df1 <- df1 %>% mutate(ans = if_else(scenario=='job', match(df1$answer, jobanswers),
if_else(scenario=='cook', match(df1$answer, cookanswers),
match(df1$answer, groupanswers))))
# -------- Permissable actual cause analysis -----------
# Checks whether ppt's answers are permissable as per Tadeg's actual causation condition
# Then analyses by participant
# Get .possAns out of json
js <- worldsdf %>% select(ends_with("possAns"))
# Remove .possAns string from colnames, transpose so easier to search and add 1 to every cell because js indexes from 0
colnames(js) <- sub(".possAns", "", colnames(js))
js <- t(js)
js <- js+1 # now it ranges 1:8 instead of 0:7
# Empty vec to put the answers in, same order as df1
isPerm <- rep(NA, 120)
# (Long winded index match - would be good to know a better way)
for (k in 1:nrow(df1))
{
row <- df1[k,]
ttype <- row$trialtype
ans <- row$ans
jsvec <- js[ttype,1:8]
isposs <- ans %in% jsvec
isPerm[k] <- isposs
}
# Add to df1 (I checked it is right)
df1 <- cbind(df1, isPerm)
# Now group by ppt to see if they mostly pick permissable answers
tf <- df1 %>% group_by(subject_id, isPerm) %>% summarise(n=n())
# Here they do (some 0, some 1-3 F), except one that has 50%. This is the analysis to do before paying them!!
# Err on side of conservative, pay them if they complete. Or at least pay but then exclude if they pick the same answer for everything
# Now is the data in a state where it can be combined with model preds?
# aim is to plot prop of ppl picking a certain answer, against the model predictions
# So the 'answers' they pick, need to be mapped against the vars in the model
# So we need a var in the df1 of 'var' (=4 options) and var took the value it took' (=8 options)
df1 <- df1 %>% mutate(ansVar = if_else(ans==1|ans==2, 'A',
if_else(ans==3|ans==4, 'Au',
if_else(ans==5|ans==6, 'B', 'Bu'))))
df1 <- df1 %>% mutate(ansVar2 = if_else(ans==1|ans==2, 'A',
if_else(ans==3, 'Au=1',
if_else(ans==4, 'Au=0',
if_else(ans==5|ans==6, 'B',
if_else(ans==7, 'Bu=1', 'Bu=0'))))))
df1 <- df1 %>% mutate(ansVar3 = if_else(ans==1, 'A=1',
if_else(ans==2, 'A=0',
if_else(ans==3, 'Au=1',
if_else(ans==4, 'Au=0',
if_else(ans==5, 'B=1',
if_else(ans==6, 'B=0',
if_else(ans==7, 'Bu=1', 'Bu=0'))))))))
# Split them by probgroup here, so they can go against the relevant model pred group for comparison
pg1 <- df1 %>% filter(probgroup==1) # 80 obs of 18
pg2 <- df1 %>% filter(probgroup==2) # 46 obs of 18
pg3 <- df1 %>% filter(probgroup==3) # 54 obs of 18
# Now summarise. For first round of plots , do ansVar=8 to see everything, so ansVar3
# If want A=a, or just 'A', take ansVar2 later
pg1prop <- pg1 %>% group_by(trialtype, ansVar3) %>% summarise(n=n()) %>% mutate(prop = n/sum(n))
pg2prop <- pg2 %>% group_by(trialtype, ansVar3) %>% summarise(n=n()) %>% mutate(prop = n/sum(n))
pg3prop <- pg3 %>% group_by(trialtype, ansVar3) %>% summarise(n=n()) %>% mutate(prop = n/sum(n))
# Now save
save(df1, pg1, pg2, pg3, pg1prop, pg2prop, pg3prop, file="../processed_data/processed_data.Rdata")
# write.csv(df1, file="../processed_collider.csv")
rm(list=ls())
# Setwd
setwd("/Users/stephaniedroop/Documents/GitHub/gw/Collider")
# Read in processed ppt data
load('processed_data/processed_data.rdata', verbose = T)
View(pg1)
?str_starts
?filter
pg1 %>% filter(grepl("^c", trialtype))
pg1c <- pg1 %>% filter(grepl("^c", trialtype))
pg1d <- pg1 %>% filter(grepl("^d", trialtype))
pg2c <- pg2 %>% filter(grepl("^c", trialtype))
pg2d <- pg2 %>% filter(grepl("^d", trialtype))
pg3c <- pg3 %>% filter(grepl("^c", trialtype))
pg3d <- pg3 %>% filter(grepl("^d", trialtype))
load('model_data/modpreds.rdata', verbose = T)
mod_preds[[1]][[6]]
mod_preds[[1]][[4]]
# Setwd
setwd("../pilot_data")
setwd("/Users/stephaniedroop/Documents/GitHub/gw/Collider/pilot_data")
# read in csvs
csvList <- lapply(list.files("./"), read.csv, stringsAsFactors = F) # this gives list of 10 when you're in the wd
# csvList <- lapply(list.files("./pilot_data"), read.csv, stringsAsFactors = F)
# bind them
dataset <- do.call(rbind, csvList)
# Get the jsons
worlds <- fromJSON(file = '../Experiment/worlds.json')
worldsdf <- as.data.frame(worlds) # 8 obs of 132 vars
conds <- fromJSON(file = '../EXperiment/conds.json')
condsdf <- as.data.frame(conds) # 2 obs of 21 vars
# Get the feedback rows and comment out
# feedback <- dataset[dataset$rowtype=='feedback',]
# Remove long strings for study id etc. Go back if you need them later
dataset <- dataset %>% select(-c(2:4,6,7))
# Data rows were generated by different trials, but we can get everything we need in one row
# But first we need to replace spaces with NA
dataset <- dataset %>% mutate(across(c('answer'), ~na_if(.,"")))
# Then can fill upwards to get the text answer in the same place as the trial info
dataset <- dataset %>% fill(answer, .direction = 'up')
# Get the pilot data
pilot5 <- read.csv('../processed_data/pilot1.csv') %>% select(-1)
# Put them together
df1 <- rbind(pilot5,dataset)
# Remove empty cols and rows
df1 <- df1 %>% select(-c(13:14))
df1 <- df1 %>% filter(cb!='NA') # Obs should be 12* no. of ppts, as each did 12 trials
# REMEMBER TO TURN ROUND THE CB ONES where cb==0 probs are 1,2,3,4 but cb==1 are 3,4,1,2
# IF WE DECIDE WE NEED IT - WE MIGHT NOT ACTUALLY - DEPENDS HOW TO COMPARE AGAINST PROBS
df1 <- df1 %>% mutate(probgroup = if_else(prob0=='10%' & prob1=='50%' | prob2=='10%' & prob3=='50%', '1',
if_else(prob0=='50%' & prob1=='80%' | prob2=='50%' & prob3=='80%', '2', '3')))
# Now reattach the number of their answer, as atm it has only recorded the text on their radio button
# First here are the arrays of possible buttons from js exp.
jobanswers <- c('The candidate had skill A',
'The candidate did not have skill A',
'The candidate demonstrated skill A',
'The candidate did not demonstrate skill A',
'The candidate had skill B',
'The candidate did not have skill B',
'The candidate demonstrated skill B',
'The candidate did not demonstrate skill B')
cookanswers <- c('The chef completed the main dish',
'The chef did not complete the main dish',
'The main dish impressed the panel',
'The main dish did not impress the panel',
'The chef completed the dessert',
'The chef did not complete the dessert',
'The dessert impressed the panel',
'The dessert did not impress the panel')
groupanswers <- c('The lecturer attended',
'The lecturer did not attend',
'The lecturer talked about the paper',
'The lecturer did not talk about the paper',
'The postdoc attended',
'The postdoc did not attend',
'The postdoc talked about the paper',
'The postdoc did not talk about the paper')
# Now make a new column with the position in array of their answer
df1 <- df1 %>% mutate(ans = if_else(scenario=='job', match(df1$answer, jobanswers),
if_else(scenario=='cook', match(df1$answer, cookanswers),
match(df1$answer, groupanswers))))
# -------- Permissable actual cause analysis -----------
# Checks whether ppt's answers are permissable as per Tadeg's actual causation condition
# Then analyses by participant
# Get .possAns out of json
js <- worldsdf %>% select(ends_with("possAns"))
# Remove .possAns string from colnames, transpose so easier to search and add 1 to every cell because js indexes from 0
colnames(js) <- sub(".possAns", "", colnames(js))
js <- t(js)
js <- js+1 # now it ranges 1:8 instead of 0:7
# Empty vec to put the answers in, same order as df1
isPerm <- rep(NA, 120)
# (Long winded index match - would be good to know a better way)
for (k in 1:nrow(df1))
{
row <- df1[k,]
ttype <- row$trialtype
ans <- row$ans
jsvec <- js[ttype,1:8]
isposs <- ans %in% jsvec
isPerm[k] <- isposs
}
# Add to df1 (I checked it is right)
df1 <- cbind(df1, isPerm)
# Now group by ppt to see if they mostly pick permissable answers
tf <- df1 %>% group_by(subject_id, isPerm) %>% summarise(n=n())
# Map the answers they gave to the variables
# PROBLEM - WHAT TO DO ABOUT THE CB PROBS
df1 <- df1 %>% mutate(ansVar = if_else(ans==1|ans==2, 'A',
if_else(ans==3|ans==4, 'Au',
if_else(ans==5|ans==6, 'B', 'Bu'))))
df1 <- df1 %>% mutate(ansVar2 = if_else(ans==1|ans==2, 'A',
if_else(ans==3, 'Au=1',
if_else(ans==4, 'Au=0',
if_else(ans==5|ans==6, 'B',
if_else(ans==7, 'Bu=1', 'Bu=0'))))))
df1 <- df1 %>% mutate(ansVar3 = if_else(ans==1, 'A=1',
if_else(ans==2, 'A=0',
if_else(ans==3, 'Au=1',
if_else(ans==4, 'Au=0',
if_else(ans==5, 'B=1',
if_else(ans==6, 'B=0',
if_else(ans==7, 'Bu=1', 'Bu=0'))))))))
# Split them by probgroup here, so they can go against the relevant model pred group for comparison
pg1 <- df1 %>% filter(probgroup==1) # 80 obs of 18
pg2 <- df1 %>% filter(probgroup==2) # 46 obs of 18
pg3 <- df1 %>% filter(probgroup==3) # 54 obs of 18
# Now summarise. For first round of plots , do ansVar=8 to see everything, so ansVar3
# If want A=a, or just 'A', take ansVar2 later
pg1prop <- pg1 %>% group_by(trialtype, ansVar3) %>% summarise(n=n()) %>% mutate(prop = n/sum(n))
pg2prop <- pg2 %>% group_by(trialtype, ansVar3) %>% summarise(n=n()) %>% mutate(prop = n/sum(n))
pg3prop <- pg3 %>% group_by(trialtype, ansVar3) %>% summarise(n=n()) %>% mutate(prop = n/sum(n))
# Now save
save(df1, pg1, pg2, pg3, pg1prop, pg2prop, pg3prop, file="../processed_data/processed_data.Rdata")
setwd("/Users/stephaniedroop/Documents/GitHub/gw/Collider/Main_scripts")
# All the params we want, put into a list of 4x2 dfs
params1 <- data.frame("0"=c(0.9,0.5,0.2,0.5), "1"=c(0.1,0.5,0.8,0.5))
params2 <- data.frame("0"=c(0.5,0.9,0.5,0.2), "1"=c(0.5,0.1,0.5,0.8))
params3 <- data.frame("0"=c(0.9,0.3,0.2,0.5), "1"=c(0.1,0.7,0.8,0.5))
row.names(params1) <- row.names(params2) <- row.names(params3) <-c ("pA",  "peA", "pB", "peB")
names(params1) <- names(params2) <- names(params3) <- c('0','1')
poss_params <- list(params1, params2, params3)
mod_preds <- vector(mode='list', length=3)
# NOTE - RUN THIS AGAIN FOR REAL
# Loop through the list of param dfs and run a series of scripts, to generate worlds, calculate model preds and plot
for (i in 1:length(poss_params)) {
source('general_cesm_a.R')
# Script contains functions, but we need to explicitly call them as dfs which will be used throughout
dfd <- world_combos(params = poss_params[[i]], structure = 'disjunctive')
dfc <- world_combos(params = poss_params[[i]], structure = 'conjunctive')
mp1d <- generic_cesm(params = poss_params[[i]], df = dfd)
mp1c <- generic_cesm(params = poss_params[[i]], df = dfc)
# Let's save these if we need to. This works but need a better structure
mod_preds[[i]][[1]] <- dfd # PROB. NOT NEEDED
mod_preds[[i]][[2]] <- dfc
#mod_preds[[1]][[i]]$dfc <- dfc
# The next script makes dfs forplotd,forplotc, with model preds used for plotting
source('unobs_a.R')
# Save them too, for later
mod_preds[[i]][[3]] <- forplotd
mod_preds[[i]][[4]] <- forplotc
mod_preds[[i]][[5]] <- wad # If you change what is taken here, it will change the indexing position later
mod_preds[[i]][[6]] <- wac
source('collider_plot_a.R')
# One way of charting the possible values of the unobserved variables, saved under `i`
# eg 'da1' is disjunctive actual , params setting 1
dchart <- paste0('~/Documents/GitHub/gw/Collider/figs/model_preds/','da',i,'.pdf')
ggsave(dchart, plot=pd, width = 7, height = 5, units = 'in')
cchart <- paste0('~/Documents/GitHub/gw/Collider/figs/model_preds/','ca',i,'.pdf')
ggsave(cchart, plot=pc, width = 7, height = 5, units = 'in')
# Important to find the right piece of the model predictions - what do we want to do with it?
# assuming wa (in unobs_a, saved as wad/wac)
}
# Save
save(mod_preds, file='../model_data/modpreds.Rdata')
# Read in processed ppt data
load('../processed_data/processed_data.rdata', verbose = T)
# Read in model preds # see master script for indexing etc -- if change what is saved in masterscript, it'll affect here
load('../model_data/modpreds.rdata', verbose = T) # list of 3
modpg1c <- mod_preds[[1]][[6]]
View(modpg1c)
View(modpg1c)
# Read in processed ppt data
load('../processed_data/processed_data.rdata', verbose = T)
# Read in model preds # see master script for indexing etc -- if change what is saved in masterscript, it'll affect here
load('../model_data/modpreds.rdata', verbose = T) # list of 3
mod_preds[[1]][[3]]
##############################################################
#### Master script for collider within gridworld project #####
##############################################################
#library(tidyverse)
rm(list=ls())
#------- 1. Create parameters, run cesm, get model predictions and save them ------------
# All the params we want, put into a list of 4x2 dfs
params1 <- data.frame("0"=c(0.9,0.5,0.2,0.5), "1"=c(0.1,0.5,0.8,0.5))
params2 <- data.frame("0"=c(0.5,0.9,0.5,0.2), "1"=c(0.5,0.1,0.5,0.8))
params3 <- data.frame("0"=c(0.9,0.3,0.2,0.5), "1"=c(0.1,0.7,0.8,0.5))
row.names(params1) <- row.names(params2) <- row.names(params3) <-c ("pA",  "peA", "pB", "peB")
names(params1) <- names(params2) <- names(params3) <- c('0','1')
poss_params <- list(params1, params2, params3)
mod_preds <- vector(mode='list', length=3)
# NOTE - RUN THIS AGAIN FOR REAL
# Loop through the list of param dfs and run a series of scripts, to generate worlds, calculate model preds and plot
for (i in 1:length(poss_params)) {
source('general_cesm_a.R')
# Script contains functions, but we need to explicitly call them as dfs which will be used throughout
dfd <- world_combos(params = poss_params[[i]], structure = 'disjunctive')
dfc <- world_combos(params = poss_params[[i]], structure = 'conjunctive')
mp1d <- generic_cesm(params = poss_params[[i]], df = dfd)
mp1c <- generic_cesm(params = poss_params[[i]], df = dfc)
# Let's save these if we need to. This works but need a better structure
#mod_preds[[i]][[1]] <- dfd # PROB. NOT NEEDED
#mod_preds[[i]][[2]] <- dfc
#mod_preds[[1]][[i]]$dfc <- dfc
# The next script makes dfs forplotd,forplotc, with model preds used for plotting
source('unobs_a.R')
# Save them too, for later
mod_preds[[i]][[1]] <- forplotd
mod_preds[[i]][[2]] <- forplotc
#mod_preds[[i]][[5]] <- wad # If you change what is taken here, it will change the indexing position later
#mod_preds[[i]][[6]] <- wac
source('collider_plot_a.R')
# One way of charting the possible values of the unobserved variables, saved under `i`
# eg 'da1' is disjunctive actual , params setting 1
dchart <- paste0('~/Documents/GitHub/gw/Collider/figs/model_preds/','da',i,'.pdf')
ggsave(dchart, plot=pd, width = 7, height = 5, units = 'in')
cchart <- paste0('~/Documents/GitHub/gw/Collider/figs/model_preds/','ca',i,'.pdf')
ggsave(cchart, plot=pc, width = 7, height = 5, units = 'in')
# Important to find the right piece of the model predictions - what do we want to do with it?
# assuming wa (in unobs_a, saved as wad/wac)
}
##############################################################
#### Master script for collider within gridworld project #####
##############################################################
#library(tidyverse)
rm(list=ls())
#------- 1. Create parameters, run cesm, get model predictions and save them ------------
# All the params we want, put into a list of 4x2 dfs
params1 <- data.frame("0"=c(0.9,0.5,0.2,0.5), "1"=c(0.1,0.5,0.8,0.5))
params2 <- data.frame("0"=c(0.5,0.9,0.5,0.2), "1"=c(0.5,0.1,0.5,0.8))
params3 <- data.frame("0"=c(0.9,0.3,0.2,0.5), "1"=c(0.1,0.7,0.8,0.5))
row.names(params1) <- row.names(params2) <- row.names(params3) <-c ("pA",  "peA", "pB", "peB")
names(params1) <- names(params2) <- names(params3) <- c('0','1')
poss_params <- list(params1, params2, params3)
mod_preds <- vector(mode='list', length=3)
# NOTE - RUN THIS AGAIN FOR REAL
# Loop through the list of param dfs and run a series of scripts, to generate worlds, calculate model preds and plot
for (i in 1:length(poss_params)) {
source('general_cesm_a.R')
# Script contains functions, but we need to explicitly call them as dfs which will be used throughout
dfd <- world_combos(params = poss_params[[i]], structure = 'disjunctive')
dfc <- world_combos(params = poss_params[[i]], structure = 'conjunctive')
mp1d <- generic_cesm(params = poss_params[[i]], df = dfd)
mp1c <- generic_cesm(params = poss_params[[i]], df = dfc)
# Let's save these if we need to. This works but need a better structure
#mod_preds[[i]][[1]] <- dfd # PROB. NOT NEEDED
#mod_preds[[i]][[2]] <- dfc
#mod_preds[[1]][[i]]$dfc <- dfc
# The next script makes dfs forplotd,forplotc, with model preds used for plotting
source('unobs_a.R')
# Save them too, for later
mod_preds[[i]][[1]] <- forplotd
mod_preds[[i]][[2]] <- forplotc
#mod_preds[[i]][[5]] <- wad # If you change what is taken here, it will change the indexing position later
#mod_preds[[i]][[6]] <- wac
source('collider_plot_a.R')
# One way of charting the possible values of the unobserved variables, saved under `i`
# eg 'da1' is disjunctive actual , params setting 1
dchart <- paste0('~/Documents/GitHub/gw/Collider/figs/model_preds/','da',i,'.pdf')
ggsave(dchart, plot=pd, width = 7, height = 5, units = 'in')
cchart <- paste0('~/Documents/GitHub/gw/Collider/figs/model_preds/','ca',i,'.pdf')
ggsave(cchart, plot=pc, width = 7, height = 5, units = 'in')
# Important to find the right piece of the model predictions - what do we want to do with it?
# assuming wa (in unobs_a, saved as wad/wac)
}
# Save
save(mod_preds, file='../model_data/modpreds.Rdata')
#--------------- 2. Get ppt data and compare with model predictions -------------------
#source('pilot_preprocessing.R')
# Notes on chart
# If we normalised the bars then it would give the prob matching approach.
# Need no y axis because it suggests probability when it isn't
# Try normalised so it becomes probability, then plot ppt against this.
# (For real thing it will have optimised softmax temp but at least we can see)
# ------------- Analysis -----------
# Still wip, see script collider_analysis.R
# (also pilot_preprocessing but I'll finish it elsewhere)
rm(list=ls())
# Read in model preds # see master script for indexing etc -- if change what is saved in masterscript, it'll affect here
load('../model_data/modpreds.rdata', verbose = T) # list of 3
mod_preds[[1]][[1]]
mod_preds[[1]][[2]]
modpredsc <- mod_preds[[1]][[2]]
modpredsd <-mod_preds[[1]][[1]]
wad <- modpredsd %>% group_by(trialtype,node3) %>% summarise(predicted = sum(wa))
View(wad)
wad <- modpredsd %>% group_by(trialtype,node3) %>% summarise(predicted = sum(wa)) %>% sum(predicted)
wad %>% sum(predicted)
wad %>% sum(wad$predicted)
View(wad)
class(wad)
wad <- as.data.frame(modpredsd %>% group_by(trialtype,node3) %>% summarise(predicted = sum(wa)))
View(wad)
class(wad)
wad %>% sum(predicted)
wad %>% sum(wad$predicted)
str(wad)
View(modpredsc)
View(modpredsd)
# Read in processed ppt data
load('../processed_data/processed_data.rdata', verbose = T)
View(pg1)
View(pg1prop)
pd <- ggplot(pgprob1, aes(x = ansvar3, y = prop,
fill = ansvar3)) +
geom_col(aes(x = ansvar3, y = prop), alpha = 0.4) +
facet_wrap(~trialtype) + #, scales='free_x'
geom_point(modpredsd, aes(x = node3, y = wa), size=3) +
theme_classic() +
theme(axis.text.x = element_text(angle = 90)) +
guides(fill = guide_legend(override.aes = list(size = 0, alpha=0.4))) +
labs(x='Node', y='Effect size', fill='Weighted average \neffect size',
shape='Assuming unobserved \nvariables are...',
colour='Assuming unobserved \nvariables are...',
title = 'Disjunctive collider',
subtitle = paste0('pA=',poss_params[[i]][1,2],', pAu=',poss_params[[i]][2,2],
', pB=',poss_params[[i]][3,2], ', pBu=',poss_params[[i]][4,2]))
pd <- ggplot(pg1prob, aes(x = ansvar3, y = prop,
fill = ansvar3)) +
geom_col(aes(x = ansvar3, y = prop), alpha = 0.4) +
facet_wrap(~trialtype) + #, scales='free_x'
geom_point(modpredsd, aes(x = node3, y = wa), size=3) +
theme_classic() +
theme(axis.text.x = element_text(angle = 90)) +
guides(fill = guide_legend(override.aes = list(size = 0, alpha=0.4))) +
labs(x='Node', y='Effect size', fill='Weighted average \neffect size',
shape='Assuming unobserved \nvariables are...',
colour='Assuming unobserved \nvariables are...',
title = 'Disjunctive collider',
subtitle = paste0('pA=',poss_params[[i]][1,2],', pAu=',poss_params[[i]][2,2],
', pB=',poss_params[[i]][3,2], ', pBu=',poss_params[[i]][4,2]))
pd <- ggplot(pg1prop, aes(x = ansvar3, y = prop,
fill = ansvar3)) +
geom_col(aes(x = ansvar3, y = prop), alpha = 0.4) +
facet_wrap(~trialtype) + #, scales='free_x'
geom_point(modpredsd, aes(x = node3, y = wa), size=3) +
theme_classic() +
theme(axis.text.x = element_text(angle = 90)) +
guides(fill = guide_legend(override.aes = list(size = 0, alpha=0.4))) +
labs(x='Node', y='Effect size', fill='Weighted average \neffect size',
shape='Assuming unobserved \nvariables are...',
colour='Assuming unobserved \nvariables are...',
title = 'Disjunctive collider',
subtitle = paste0('pA=',poss_params[[i]][1,2],', pAu=',poss_params[[i]][2,2],
', pB=',poss_params[[i]][3,2], ', pBu=',poss_params[[i]][4,2]))
pd
pd <- ggplot(pg1prop, aes(x = ansvar3, y = prop,
fill = ansvar3)) +
geom_col(aes(x = ansvar3, y = prop), alpha = 0.4) +
facet_wrap(~trialtype) + #, scales='free_x'
geom_point(aes(modpredsd$node3, y = wa), size=3) +
theme_classic() +
theme(axis.text.x = element_text(angle = 90)) +
guides(fill = guide_legend(override.aes = list(size = 0, alpha=0.4))) +
labs(x='Node', y='Effect size', fill='Weighted average \neffect size',
shape='Assuming unobserved \nvariables are...',
colour='Assuming unobserved \nvariables are...',
title = 'Disjunctive collider',
subtitle = paste0('pA=',poss_params[[i]][1,2],', pAu=',poss_params[[i]][2,2],
', pB=',poss_params[[i]][3,2], ', pBu=',poss_params[[i]][4,2]))
pd <- ggplot(pg1prop, aes(x = ansvar3, y = prop,
fill = ansvar3)) +
geom_col(aes(x = ansvar3, y = prop), alpha = 0.4) +
facet_wrap(~trialtype) + #, scales='free_x'
geom_point(aes(modpredsd$node3, y = wa), size=3) +
theme_classic() +
theme(axis.text.x = element_text(angle = 90)) +
guides(fill = guide_legend(override.aes = list(size = 0, alpha=0.4))) +
labs(x='Node', y='Effect size', fill='Weighted average \neffect size',
shape='Assuming unobserved \nvariables are...',
colour='Assuming unobserved \nvariables are...',
title = 'Disjunctive collider',
#subtitle = paste0('pA=',poss_params[[i]][1,2],', pAu=',poss_params[[i]][2,2],
#', pB=',poss_params[[i]][3,2], ', pBu=',poss_params[[i]][4,2]))
pd
pd <- ggplot(pg1prop, aes(x = ansvar3, y = prop,
pd <- ggplot(pg1prop, aes(x = ansvar3, y = prop,
fill = ansvar3)) +
geom_col(aes(x = ansvar3, y = prop), alpha = 0.4) +
facet_wrap(~trialtype) + #, scales='free_x'
geom_point(aes(modpredsd$node3, y = wa), size=3) +
theme_classic() +
theme(axis.text.x = element_text(angle = 90)) +
guides(fill = guide_legend(override.aes = list(size = 0, alpha=0.4))) +
labs(x='Node', y='Effect size', fill='Weighted average \neffect size',
shape='Assuming unobserved \nvariables are...',
colour='Assuming unobserved \nvariables are...',
title = 'Disjunctive collider')
pd
pd <- ggplot(pg1prop, aes(x = ansVar3, y = prop,
fill = ansvar3)) +
geom_col(aes(x = ansVar3, y = prop), alpha = 0.4) +
facet_wrap(~trialtype) + #, scales='free_x'
geom_point(aes(modpredsd$node3, y = wa), size=3) +
theme_classic() +
theme(axis.text.x = element_text(angle = 90)) +
guides(fill = guide_legend(override.aes = list(size = 0, alpha=0.4))) +
labs(x='Node', y='Effect size', fill='Weighted average \neffect size',
shape='Assuming unobserved \nvariables are...',
colour='Assuming unobserved \nvariables are...',
title = 'Disjunctive collider')
pd
pd <- ggplot(pg1prop, aes(x = ansVar3, y = prop,
fill = ansVar3)) +
geom_col(aes(x = ansVar3, y = prop), alpha = 0.4) +
facet_wrap(~trialtype) + #, scales='free_x'
geom_point(aes(modpredsd$node3, y = wa), size=3) +
theme_classic() +
theme(axis.text.x = element_text(angle = 90)) +
guides(fill = guide_legend(override.aes = list(size = 0, alpha=0.4))) +
labs(x='Node', y='Effect size', fill='Weighted average \neffect size',
shape='Assuming unobserved \nvariables are...',
colour='Assuming unobserved \nvariables are...',
title = 'Disjunctive collider')
pd
pd <- ggplot(pg1prop, aes(x = ansVar3, y = prop,
fill = ansVar3)) +
geom_col(aes(x = ansVar3, y = prop), alpha = 0.4) +
facet_wrap(~trialtype) + #, scales='free_x'
geom_point(aes(modpredsd$node3, y = modpreds$wa), size=3) +
theme_classic() +
theme(axis.text.x = element_text(angle = 90)) +
guides(fill = guide_legend(override.aes = list(size = 0, alpha=0.4))) +
labs(x='Node', y='Effect size', fill='Weighted average \neffect size',
shape='Assuming unobserved \nvariables are...',
colour='Assuming unobserved \nvariables are...',
title = 'Disjunctive collider')
pd
pd <- ggplot(pg1prop, aes(x = ansVar3, y = prop,
fill = ansVar3)) +
geom_col(aes(x = ansVar3, y = prop), alpha = 0.4) +
facet_wrap(~trialtype) + #, scales='free_x'
geom_point(aes(modpredsd$node3, y = modpredsd$wa), size=3) +
theme_classic() +
theme(axis.text.x = element_text(angle = 90)) +
guides(fill = guide_legend(override.aes = list(size = 0, alpha=0.4))) +
labs(x='Node', y='Effect size', fill='Weighted average \neffect size',
shape='Assuming unobserved \nvariables are...',
colour='Assuming unobserved \nvariables are...',
title = 'Disjunctive collider')
pd
