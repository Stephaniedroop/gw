# ------------- CESM HEAVY FUNCTION ----------------------------
# A function to run the generic CESM, but it takes a long time. Takes arguments of:
# - params that lists the base rates and strengths of exog noise u vars
# - a df of all the world combos with probs, generated by function world_combos
# (some redundancy across these two functions but probably ok)

# There is another faster version in 'functions.R' - this is just to keep a working version safe

generic_cesm <- function(params, df, s) { 
  #s <- s
    n_causes <- nrow(params)
    causes <- rownames(params)
    structure <- df$structure
    # Make same shape df to put the effect size / correlations in - it doesn't have to be empty because the values will be overwritten
    mp <- df[,1:4]
    worlds <- nrow(df)
    # From here on we assign responsibility to the causes by simulating cfs and counting in how many of them the outcome happened the same
    # First, loop through possible world settings 
    for (c_ix in 1:worlds) #16
    {
      # Take the current case
      case <- df[c_ix,] # one obs of 8
      # Make an empty df of size c_cf (ie 10000) to put the generated counterfactual settings in 
      cfs <- data.frame(matrix(NA, nrow = N_cf, ncol = ncol(df))) 
      colnames(cfs) <- colnames(df)
      cfs$Match <- rep(NA, N_cf) # Now it's 1000 obs of 9
      # Then, generate N counterfactuals
      for (i in 1:N_cf)
      {
        #cf_cs <- as.numeric(case[1:n_causes]) # Set of causes from the current world - set of 4 values - here it was 0000
        # Now resample what needs to be resampled
        resample <- c(T,T,T,T)#runif(n_causes) > s # Picks the ones to be resampled, the ones that are not within 'stability'
        p <- params[,2] # The second column, ie. the p_eachvar==1 # EXPENSIVE COMMAND
        cf_cs[resample] <- runif(sum(resample)) < p[resample] # Resamples for T ones, and replaces the cf value. Here became 0111
        
        # Test row
        cf_cs <- c(0,0,0,0)
        
        # Pull out the world that match these outcomes. IT WILL ONLY BE ONE. (The previous bigger probabilistic version could have more)
        idx = c(1:nrow(df)) # The index starts with everything
        for (j in 1:n_causes){
          idx = intersect(idx, which(df[,causes[j]]==cf_cs[j])) # Then progressively filters down for each cause that matches
        } # It gives us the number of a row of the df
        
        # This is the 'counterfactual'
        cf <- df[idx,] # EXPENSIVE COMMAND 
  
        # Get this row and call it cf_cases
        cf_cases <- df[idx,] 
        # ... and counts them
        n_outcomes <- nrow(cf_cases)
        #Sample one outcome according to its probability - for us now this is deterministic so comment out and find a more general way
        cf_out_ix <- sample(x=1:n_outcomes, size = 1, p=cf_cases$pOutcome)
        cf <- cf_cases[cf_out_ix,] 
        
        # Check if it matches the true outcome; adds column T/F
        cf$Match <- cf$E==case$E
        # Add the current now-finished case of N to the collection of cfs
        cfs[i,] <- cf # THIS IS AN EXPENSIVE COMMAND
      }
      # Now calculate cf responsibility for each cause 
      cor_sizes <- rep(NA, n_causes)
      # for (cause in 1:n_causes)
      {
        # Calculate correlation -
        # the second part sets correlation negative when cause is inhibitory #*(c(-1,1)[as.numeric(case[[causes[cause]]])+1])
        cor_sizes[cause] <- cor(cfs[[causes[cause]]], cfs$Match) *(c(-1,1)[as.numeric(case[[causes[cause]]])+1])
      }
      mp[c_ix,1:4] <- cor_sizes
      cat(c_ix, cor_sizes, '\n')
    }
  mp$index <- 1:nrow(mp)
  mp$structure <- structure
  mp$s <- s
  mp
}
